import os
import re
import sys

### Run this script from `BFRUH/Electronics/scripts`
### This script appends symbols to the bfr_resistors library and spice models files to the
### `spice_models/bfr_resistors` folder.
### This script may be called with any number of arguments. Each argument is the path to
### a part family definition file for which symbols and spice models should be autogenerated.
###
### A part family definition file uses a custom format called "Flat XML". Any number of named
### text sections can be present in such a file. The text contained by some section named
### "section-name" must be delimited by the strings "<section-name>" and "</section-name>".
### No special handling of nested sections occurs, and only one copy of a section with some
### specific name may exist within a Flat XML file.
###
### A part family definition file must contain the following three sections:
### * A "symbol-code" section provides template KiCad symbol definition code from which all the
###   parts are made. Substitutions of literal strings into named variables within that section
###   (which are created with {VarName} syntax) allow parts within a family to be differentiated.
### * A "spice-code" section provides template SPICE code with which to make the spice model file
###   for the part. It uses the same literal string substitutions as the "symbol-code" section.
### * A "part-attributes" section in CSV format gives properties of each part which map to the
###   variable names which can be substituted into part code. The first row of the CSV ties the
###   column to a specific variable name. Each subsequent row must either be blank or contain
###   the string values which should be substituted into the variables for a specific part.
###
### Symbols are identified by their manufacturer part number (under the attribute "Mfr P/N").
### Every part family definition file must have a "Mfr P/N" attribute in its "part-attributes"
### section to be able to be handled by this script.
### * This field is used to name and locate the spice file corresponding to a part.
### * This field is used to identify if a part which is being generated is already in the
###   library and update the existing copy instead of adding a near-identical duplicate part.
### Symbols generated by this script should include the "Created by" attribute in their symbol
### definition code. The value of this field should reference both the name of this script
### ("resistor_generator.py") and the name of the part family definition file from which the
### symbol comes.
###
### Updating our workflow to use new parts through part definition files must not involve an
### update to the manufacturer part number in the part definition file, even if the updates are
### caused by selection of a better part to replace one in the library or by obsolescence of a
### part in the library. This is because parts are idenfied by the manufacturer part number, and
### accordingly a manufacturer part number which is removed from the definition file is not
### recognized as ever having been defined there. Therefore, the manufacturer part number field
### on a part in a schematic must be understood as a guideline, rather than a requirement. Any
### part which is a drop-in replacement for the specified part (per the criteria for a drop-in
### replacement in the library's documentation on Notion) may be used on the board. Accordingly,
### workflow updates to introduce new parts should simply update the supplier part numbers on
### a part and leave the original manufacturer part number in place.
### Further, when a library is created, the most available and affordable parts may vary based
### on supplier. The initial manufacturer part number designation for a part will likely only
### match a subset of the suppliers that exist. This subset should be consistent across an
### entire part family definition file and specified in its documentation on Notion.
###
### The "BFRUH_DIR" substitution variable is not made available by this script. It will not be
### substituted in symbol code or SPICE code.

dir, _ = os.path.split(__file__)

# Utility functions for parsing the symbol library file and the family specification file


def get_file_as_string(filepath):
    file = open(filepath)
    data = "".join(file.readlines())
    file.close()
    return data


def get_flat_xml_attribute(xml_string, tag):
    start_index = xml_string.index("<" + tag + ">") + len(tag) + 2
    end_index = xml_string.index("</" + tag + ">")
    second_start = -1
    try:
        second_start = xml_string.index("<" + tag + ">", start_index)
    except ValueError:
        pass
    second_end = -1
    try:
        second_end = xml_string.index("</" + tag + ">", end_index + 1)
    except ValueError:
        pass
    if second_start >= 0 or second_end >= 0:
        raise ValueError(
            "Flat XML strings must contain only one copy of each start and end tag."
        )
    output = xml_string[start_index:end_index]
    return output


for family_spec in sys.argv[1:]:
    # Read and parse the family specification file

    family_spec = get_file_as_string(os.path.join(dir, family_spec))
    symbol_template = get_flat_xml_attribute(family_spec, "symbol-code")
    spice_template = get_flat_xml_attribute(family_spec, "spice-code")
    family_parts = get_flat_xml_attribute(family_spec, "part-attributes")

    part_attributes = []
    family_part_attributes = list(
        filter(
            (lambda x: not x.isspace() and not (len(x) == 0)), family_parts.split("\n")
        )
    )
    attr_name_list = family_part_attributes[0].split(",")
    family_part_attributes = family_part_attributes[1:]
    for part_string in family_part_attributes:
        attr_list = part_string.split(",")
        part = dict()
        i = 0
        for attr_name in attr_name_list:
            part[attr_name] = attr_list[i]
            i += 1
        part["BFRUH_DIR"] = "{BFRUH_DIR}"
        part_attributes.append(part)

    # Update symbol library file

    sym_lib_code = get_file_as_string(
        os.path.join(os.path.split(dir)[0], "symbols", "bfr_resistors.kicad_sym")
    )

    # Remove existing parts from the family which are in the library, so they can be updated
    for part in part_attributes:
        try:
            start_index = sym_lib_code.index('(symbol "' + part["Mfr P/N"] + '"')
            end_index = start_index + 1
            parens = 1
            while parens > 0:
                match (sym_lib_code[end_index]):
                    case "(":
                        parens += 1
                    case ")":
                        parens -= 1
                    case other:
                        pass
                end_index += 1
            sym_lib_code = sym_lib_code[:start_index] + sym_lib_code[end_index:]
        except ValueError:
            # part has not been found in the library, so we don't need to remove it
            pass

    # Add in updated parts from family spec
    insertion_point = len(sym_lib_code) - 1
    while sym_lib_code[insertion_point] != ")":
        insertion_point -= 1
    for part in part_attributes:
        sym_lib_code = (
            sym_lib_code[:insertion_point]
            + symbol_template.format_map(part)
            + sym_lib_code[insertion_point:]
        )
    sym_lib_code = re.sub("\n\s*\n", "\n\n", sym_lib_code)

    # Write back library
    lib_file = open(
        os.path.join(os.path.split(dir)[0], "symbols", "bfr_resistors.kicad_sym"), "w"
    )
    lib_file.write(sym_lib_code)
    lib_file.close()

    # Write simulation files to be used

    for part in part_attributes:
        path = os.path.join(
            os.path.split(dir)[0],
            "spice_models",
            "bfr_resistors",
            part["Mfr P/N"] + ".lib",
        )
        sim_file = open(path, "w")
        sim_file.write(spice_template.format_map(part))
        sim_file.close()
